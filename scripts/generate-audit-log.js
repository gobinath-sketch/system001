const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

const TARGETS = [
  { name: 'Root', dir: '.' },
  { name: 'Client', dir: 'client' },
  { name: 'Server', dir: 'server' },
];

function nowIso() {
  return new Date().toISOString();
}

function timestampForFile() {
  const d = new Date();
  const pad = (n) => String(n).padStart(2, '0');
  return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}

function runCommand(command, args, cwd) {
  const startedAt = nowIso();
  const result = spawnSync(command, args, {
    cwd,
    encoding: 'utf8',
    shell: false,
  });
  const endedAt = nowIso();

  return {
    startedAt,
    endedAt,
    exitCode: result.status,
    stdout: result.stdout || '',
    stderr: result.stderr || '',
    error: result.error ? String(result.error.message || result.error) : '',
  };
}

function normalizeMetadataVulns(metadataVulns) {
  const fallback = { low: 0, moderate: 0, high: 0, critical: 0, info: 0, total: 0 };
  if (!metadataVulns || typeof metadataVulns !== 'object') return fallback;
  const low = Number(metadataVulns.low || 0);
  const moderate = Number(metadataVulns.moderate || 0);
  const high = Number(metadataVulns.high || 0);
  const critical = Number(metadataVulns.critical || 0);
  const info = Number(metadataVulns.info || 0);
  const total = Number(metadataVulns.total || (low + moderate + high + critical + info));
  return { low, moderate, high, critical, info, total };
}

function parseAuditJson(output) {
  try {
    return JSON.parse(output);
  } catch {
    return null;
  }
}

function fixAvailableText(fixAvailable) {
  if (fixAvailable === true) return 'Yes';
  if (fixAvailable === false) return 'No';
  if (!fixAvailable) return 'Unknown';
  if (typeof fixAvailable === 'object') {
    const name = fixAvailable.name || 'package';
    const isMajor = fixAvailable.isSemVerMajor ? ' (major)' : '';
    return `Yes: ${name}${isMajor}`;
  }
  return String(fixAvailable);
}

function listVia(via) {
  if (!Array.isArray(via)) return '';
  return via
    .map((item) => {
      if (typeof item === 'string') return item;
      if (item && typeof item === 'object') {
        const source = item.source ? `#${item.source}` : '';
        const title = item.title || item.name || 'advisory';
        return [title, source].filter(Boolean).join(' ');
      }
      return '';
    })
    .filter(Boolean)
    .join('; ');
}

function mdEscape(val) {
  return String(val ?? '').replace(/\|/g, '\\|').replace(/\n/g, ' ');
}

function analyzeTarget(target) {
  const cwd = path.resolve(target.dir);
  const command = process.platform === 'win32' ? 'npm.cmd' : 'npm';
  const args = ['audit', '--json'];
  const execution = runCommand(command, args, cwd);
  const json = parseAuditJson(execution.stdout);

  const metadataVulns = normalizeMetadataVulns(json?.metadata?.vulnerabilities);
  const totalDependencies = Number(json?.metadata?.totalDependencies || 0);
  const vulnerabilities = json?.vulnerabilities && typeof json.vulnerabilities === 'object'
    ? Object.entries(json.vulnerabilities).map(([pkg, details]) => ({
      packageName: pkg,
      severity: details?.severity || 'unknown',
      isDirect: Boolean(details?.isDirect),
      range: details?.range || '',
      via: listVia(details?.via),
      fixAvailable: fixAvailableText(details?.fixAvailable),
    }))
    : [];

  let status = 'Completed';
  if (execution.error) status = 'Command Error';
  else if (!json && execution.exitCode !== 0) status = 'Failed (No JSON)';
  else if (metadataVulns.total > 0) status = 'Completed (Vulnerabilities Found)';
  else status = 'Completed (No Vulnerabilities)';

  return {
    target,
    cwd,
    command: `${command} ${args.join(' ')}`,
    execution,
    parsed: Boolean(json),
    status,
    totalDependencies,
    metadataVulns,
    vulnerabilities,
  };
}

function buildMarkdown(results) {
  const generatedAt = nowIso();
  const machine = process.env.COMPUTERNAME || process.env.HOSTNAME || 'Unknown';

  let md = '';
  md += '# NPM Audit Log Report\n\n';
  md += '## Report Metadata\n\n';
  md += `- Generated At: ${generatedAt}\n`;
  md += `- Generated By: ${process.env.USERNAME || process.env.USER || 'Unknown'}\n`;
  md += `- Machine: ${machine}\n`;
  md += `- Node Version: ${process.version}\n\n`;

  md += '## Executive Summary\n\n';
  md += '| S.No | Scope | Location | Audit Command | Start Time | End Time | Status | Critical | High | Moderate | Low | Info | Total Vulns | Total Dependencies |\n';
  md += '| --- | --- | --- | --- | --- | --- | --- | ---: | ---: | ---: | ---: | ---: | ---: | ---: |\n';

  results.forEach((r, i) => {
    md += `| ${i + 1} | ${mdEscape(r.target.name)} | ${mdEscape(r.cwd)} | ${mdEscape(r.command)} | ${mdEscape(r.execution.startedAt)} | ${mdEscape(r.execution.endedAt)} | ${mdEscape(r.status)} | ${r.metadataVulns.critical} | ${r.metadataVulns.high} | ${r.metadataVulns.moderate} | ${r.metadataVulns.low} | ${r.metadataVulns.info} | ${r.metadataVulns.total} | ${r.totalDependencies} |\n`;
  });

  md += '\n## Detailed Findings\n\n';

  results.forEach((r, i) => {
    md += `### ${i + 1}. ${r.target.name}\n\n`;
    md += `- Location: \`${r.cwd}\`\n`;
    md += `- Command: \`${r.command}\`\n`;
    md += `- Start Time: ${r.execution.startedAt}\n`;
    md += `- End Time: ${r.execution.endedAt}\n`;
    md += `- Exit Code: ${r.execution.exitCode}\n`;
    md += `- Status: ${r.status}\n\n`;

    if (r.execution.error) {
      md += '**Command Error**\n\n';
      md += '```text\n';
      md += `${r.execution.error}\n`;
      md += '```\n\n';
    }

    if (r.vulnerabilities.length === 0) {
      md += 'No vulnerability entries reported.\n\n';
    } else {
      md += '| Package | Severity | Direct Dependency | Affected Range | Via | Fix Available |\n';
      md += '| --- | --- | --- | --- | --- | --- |\n';
      r.vulnerabilities
        .sort((a, b) => String(a.severity).localeCompare(String(b.severity)))
        .forEach((v) => {
          md += `| ${mdEscape(v.packageName)} | ${mdEscape(v.severity)} | ${v.isDirect ? 'Yes' : 'No'} | ${mdEscape(v.range)} | ${mdEscape(v.via)} | ${mdEscape(v.fixAvailable)} |\n`;
        });
      md += '\n';
    }

    if (r.execution.stderr.trim()) {
      md += '<details>\n';
      md += '<summary>stderr output</summary>\n\n';
      md += '```text\n';
      md += `${r.execution.stderr.trim()}\n`;
      md += '```\n\n';
      md += '</details>\n\n';
    }
  });

  const hasAnyVuln = results.some((r) => r.metadataVulns.total > 0);
  md += '## Final Conclusion\n\n';
  if (hasAnyVuln) {
    md += '- Vulnerabilities were detected in one or more scopes.\n';
    md += '- Review fix availability and apply updates in a controlled release process.\n';
  } else {
    md += '- No vulnerabilities were reported across the scanned scopes.\n';
  }

  return md;
}

function main() {
  const results = TARGETS.map(analyzeTarget);
  const markdown = buildMarkdown(results);

  const outputDir = path.resolve('audit-logs');
  if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

  const fileName = `npm-audit-log-${timestampForFile()}.md`;
  const fullPath = path.join(outputDir, fileName);
  fs.writeFileSync(fullPath, markdown, 'utf8');

  console.log(`Audit log generated: ${fullPath}`);
}

main();
